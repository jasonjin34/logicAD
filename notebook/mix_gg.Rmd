---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
# using mix gaussien distribution for the location distribution 

# %load_ext autoreload
# %autoreload 2

# get image transform and feed into GroundingDINO

from anomalib.models.logicad.sliding_window import (
    dino_image_transform, 
    patch_extraction_from_box, 
    get_bbx_from_query
)

import torch
import numpy as np
import os
import glob
from anomalib.utils.llm import load_gdino_model
from anomalib.utils.llm import img2text, txt2sum
from sliding_window import load_image, display_image, image_unfold, display_multiple_image

from einops import rearrange

from numpy import dot
from numpy.linalg import norm
from sklearn.metrics import roc_auc_score
from sklearn import metrics
from sklearn.metrics import precision_recall_curve
```

```{python}
# test juice bottle
path = "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/mini/pushpins/test/good/001.png"

api = "/home/erjin/git/Logic_AD_LLM/keys/gpt.json"
```

```{python}
img, trans_img = dino_image_transform(path)
model = load_gdino_model(ckpt_path="/home/erjin/git/Logic_AD_LLM/datasets/GroundingDino/groundingdino_swint_ogc.pth")
boxes, logits, phrases = get_bbx_from_query(image=trans_img, model=model, box_threshold=0.35, text_threshold=0.35, query="pushpin")
```

```{python}
# convert boxes to numy list

def convert_centroid_to_numpy(boxes):
    if not isinstance(boxes, np.ndarray):
        boxes = boxes.detach().cpu().numpy()
    output_list: list = []
    for b in boxes:
        x, y, w, h = b
        output_list.append([x, y])
    return output_list
    

training_point = []
dir_path = "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/original/pushpins/test/good/"
good_image_pths = glob.glob(os.path.join(dir_path, "*"))
for p in good_image_pths:
    _, trans_img = dino_image_transform(p)
    boxes, _, _ = get_bbx_from_query(trans_img, model=model, box_threshold=0.35, text_threshold=0.35, query="pushpin")
    training_point.append(convert_centroid_to_numpy(boxes))


test_point = []
dir_path = "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/original/pushpins/test/logical_anomalies/"
test_image_pths = glob.glob(os.path.join(dir_path, "*"))
for p in test_image_pths:
    _, trans_img = dino_image_transform(p)
    boxes, _, _ = get_bbx_from_query(trans_img, model=model, box_threshold=0.35, text_threshold=0.35, query="pushpin")
    test_point.append(convert_centroid_to_numpy(boxes))
```

```{python}
print(len(training_point), len(test_point))
```

```{python}
def calculate_disance(v1, v2):
    def l2_dis(p1, p2):
        return np.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

    dis_list = []
    for p1 in v1:
        min_dis = 100
        for p2 in v2:
            temp_dis = l2_dis(p1, p2)
            if temp_dis < min_dis:
                min_dis = temp_dis
        dis_list.append(min_dis)
    return dis_list
```

```{python}
calculate_disance(training_point[0], test_point[1])
```

```{python}
def cos_sim(a, b):
    return dot(a, b)/(norm(a)*norm(b))
```

```{python}
reference_point = training_point[11]
```

```{python}
good_score = []
for ti in training_point[1:]:
    good_score.append(norm(calculate_disance(reference_point, ti)))

gt_good = [0 for _ in range(len(good_score))]
```

```{python}
test_score = []
for ti in test_point:
    test_score.append(norm(calculate_disance(reference_point, ti)))

gt_test =  [1 for _ in range(len(test_score))]
```

```{python}
y = gt_good + gt_test
pred = good_score + test_score
```

```{python}
fpr, tpr, thresholds = metrics.roc_curve(y, pred, pos_label=1)
metrics.auc(fpr, tpr)
```

```{python}

precision, recall, thresholds = precision_recall_curve(y, pred)
numerator = 2 * recall * precision
denom = recall + precision
f1_scores = np.divide(numerator, denom, out=np.zeros_like(denom), where=(denom!=0))
max_f1 = np.max(f1_scores)
max_f1_thresh = thresholds[np.argmax(f1_scores)]
```

```{python}
print(max_f1, max_f1_thresh)
```

```{python}

```
