---
jupyter:
  jupytext:
    formats: ipynb,Rmd
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.16.2
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
# using mix gaussien distribution for the location distribution 
# %load_ext autoreload
# %autoreload 2

import torch
import numpy as np
import os
import glob
from numpy import dot
from numpy.linalg import norm
from sklearn.metrics import roc_auc_score
from sklearn import metrics
from sklearn.metrics import precision_recall_curve
from einops import rearrange
from sklearn.mixture import GaussianMixture

from anomalib.utils.llm import load_gdino_model, img2text, txt2sum
from anomalib.models.logicad.sliding_window import (
    dino_image_transform, 
    patch_extraction_from_box, 
    get_bbx_from_query,
    convert_centroid_to_numpy,
    calculate_centroidmap_disance
)

gdino_ckpt = "/home/erjin/git/Logic_AD_LLM/datasets/GroundingDino/groundingdino_swint_ogc.pth"
api = "/home/erjin/git/Logic_AD_LLM/keys/gpt.json"
model = load_gdino_model(ckpt_path=gdino_ckpt)
```

```{python}
def generate_object_centroid(
    gdino_model,
    dir_path,
    box_threshold = 0.35,
    text_threshold = 0.35,
    query="pushpin",
):
    centroid_list = []
    image_paths = glob.glob(os.path.join(dir_path, "*"))
    for p in image_paths:
        _, trans_img = dino_image_transform(p)
        boxes, _, _ = get_bbx_from_query(
            trans_img, 
            model=gdino_model, 
            box_threshold=box_threshold, 
            text_threshold=text_threshold, 
            query=query,
        )
        centroid_list.append(convert_centroid_to_numpy(boxes))
    return centroid_list


def calculate_f1_max(y, pred):
    precision, recall, thresholds = precision_recall_curve(y, pred)
    numerator = 2 * recall * precision
    denom = recall + precision
    f1_scores = np.divide(numerator, denom, out=np.zeros_like(denom), where=(denom!=0))
    max_f1 = np.max(f1_scores)
    max_f1_thresh = thresholds[np.argmax(f1_scores)]
    return max_f1

def calculate_auroc(y, pred, pos_label=1):
    fpr, tpr, thresholds = metrics.roc_curve(y, pred, pos_label=1)
    auroc = metrics.auc(fpr, tpr)
    return auroc

def generate_reference_points(
    train_img=train_img,
    model=model
):
    _, trans_img = dino_image_transform(train_img)
    def ref_points_with_flip(img, rotation=None):
        if rotation is not None:
            img = torch.flip(img, rotation)
        boxes, _, _ = get_bbx_from_query(
            img, 
            model=model, 
            box_threshold=0.35, 
            text_threshold=0.35, 
            query="pushpin",
        )
        return boxes[:, :2]
    rotation_list = [None]
    abs_list = [ref_points_with_flip(img=trans_img, rotation=r) for r in rotation_list]
    return abs_list[0]
```

```{python}
test_good_image_dir = "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/original/pushpins/test/good/"
test_an_image_dir = "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/original/pushpins/test/logical_anomalies/"
good_centroid_list = generate_object_centroid(gdino_model=model, dir_path=test_good_image_dir)
ab_centroid_list = generate_object_centroid(gdino_model=model, dir_path=test_an_image_dir)
```

```{python}
train_img =  "/home/erjin/git/Logic_AD_LLM/datasets/MVTec_Loco/original/pushpins/train/good/021.png"
reference_img = generate_reference_points(train_img=train_img)
```

```{python}
def evaluation(
    test_good,
    test_ab,
    reference_img,
):
    def generate_distance_score(test_img, reference_img, gt):
        score = []
        for img in test_img:
            tmp_score = []
            score.append(norm(calculate_centroidmap_disance(reference_img, img)))
        gt = [gt for _ in range(len(score))]
        return score, gt
    
    test_good, gt_test_good = generate_distance_score(test_good, reference_img, 0)
    test_ab, gt_test_ab = generate_distance_score(test_ab, reference_img, 1)

    y = gt_test_good + gt_test_ab
    y_pred = test_good + test_ab
    print(f"f1 max {calculate_f1_max(y, y_pred)}\n") 
    print(f"auroc {calculate_auroc(y, y_pred)}\n") 
```

```{python}
evaluation(
    test_good = good_centroid_list,
    test_ab = ab_centroid_list,
    reference_img = reference_img,
)
```
